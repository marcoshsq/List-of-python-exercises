# -*- coding: utf-8 -*-
"""List of Keywords in Python

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZFb5TrXp2usXZGH6TOYaZ-X8b4V-65Hd

# List of Keywords in Python

Este notebook fornece informações breves sobre todas as palavras-chave usadas em Python.

Palavras-chave são as palavras reservadas em Python. Não podemos usar uma palavra-chave como nome de variável, nome de função ou qualquer outro identificador.

[Fonte](https://www.programiz.com/python-programming/keyword-list)
"""

# Keywords podem ser removidas e adicionadas.
# Para saber quais keywords temos no momomento
import keyword
print(keyword.kwlist)

"""# True, False

True e False são valores de verdade em Python. Eles são os resultados de operações de comparação ou operações lógicas (booleanas) em Python. Por exemplo:
"""

1 == 1 # true

5 > 3 # True

True or False # True

10 <= 1 # False

3 > 7 # False

True and False # False

"""# None

None é uma constante especial em Python que representa a ausência de um valor ou valor nulo.

É um objeto de seu próprio tipo de dados, o NoneType. Não podemos criar vários objetos None, mas podemos atribuí-los a variáveis. Essas variáveis serão iguais entre si.

Devemos tomar cuidado especial para que None não implique False, 0 ou qualquer lista vazia, dicionário, string etc. Por exemplo:
"""

None == 0 # False

None == [] # False

None == False # False

x = None
y = None
x == y # True

"""Funções void que não retornam nada retornarão um objeto None automaticamente. 

None também é retornado por funções nas quais o fluxo do programa não encontra uma instrução de retorno. Por exemplo:
"""

def a_void_function():
    a = 1
    b = 2
    c = a + b

x = a_void_function()
print(x)

"""# and, or , not

Operadores lógicos, seguem suas regras de tabela verdade.

* and - V com V dá V, ou seja, só é verdadeiro se todos forem verdadeiros;
* or - F com F dá F, ou seja, só dá falso se todos forem falsos;
* not - troca o valor lógico.
"""

# and 

x = 1 
y = 5 

if x == 5 and y == 5:
    print(True)
else:
    print(False)

# Como apenas uma das condições é verdadeira
# O retorno é falso no caso do and

# and 

x = 1 
y = 5 

if x == 5 or y == 5:
    print(True)
else:
    print(False)

# Como apenas uma das condições é verdadeira
# O retorno é True no caso do or

# not

x = 1 
y = 5 

if not x == y :
    print(True)
else:
    print(False)

"""# as

as é usado para criar um pseudônimo (apelido) ao importar um módulo. Significa dar um nome diferente (definido pelo usuário) a um módulo ao importá-lo.

Por exemplo, Python tem um módulo padrão chamado math. Suponha que queremos calcular qual a raiz quadrada de pi usando um apelido. Podemos fazer da seguinte forma usando as:
"""

import math as calculadora_do_python

calculadora_do_python.sqrt(calculadora_do_python.pi)
# mas existem convenções de apelidos, então usar com sabedoria u.u

"""# assert

assert é usado para fins de depuração.

Durante a programação, às vezes desejamos conhecer o estado interno ou verificar se nossas suposições são verdadeiras. assert nos ajuda a fazer isso e encontrar bugs de forma mais conveniente. assert é seguido por uma condição.

Se a condição for verdadeira, nada acontece. Mas se a condição for falsa, AssertionError é gerado. Por exemplo:
"""

a = 4
assert a < 5
assert a > 5, "O valor de 'a' é muito pequeno"

"""# async, await

As palavras-chave async e await são fornecidas pela biblioteca assíncrona em Python. 

Eles são usados para escrever código concorrente em Python. Por exemplo,
"""

import asyncio

async def main():
    print('Hello')
    await asyncio.sleep(1)
    print('world')

"""# break, continue

break e continue são usados dentro de loops for e while para alterar seu comportamento normal.

break terminará o menor loop em que estiver e o controle fluirá para a instrução imediatamente abaixo do loop. continue faz com que termine a iteração atual do loop, mas não o loop inteiro.

Isso pode ser ilustrado com os dois exemplos a seguir:
"""

for i in range(1,11):
    if i == 5:
        break
    print(i)

for i in range(1,11):
    if i == 5:
        continue
    print(i)

"""# class e def

### class é usado para definir uma nova classe definida pelo usuário em Python.

Classe é uma coleção de atributos e métodos relacionados que tentam representar uma situação do mundo real. Essa ideia de juntar dados e funções em uma classe é central para o conceito de programação orientada a objetos (OOP).

As classes podem ser definidas em qualquer lugar em um programa. Mas é uma boa prática definir uma única classe em um módulo. 

### Já def é usado para definir uma função definida pelo usuário.

Função é um bloco de instruções relacionadas, que juntas realizam alguma tarefa específica. Ele nos ajuda a organizar o código em partes gerenciáveis e também a realizar algumas tarefas repetitivas.
"""

class ExampleClass:

    def function(self):
        pass

"""# del

del é usado para excluir a referência a um objeto. 

Tudo é objeto em Python. Podemos excluir uma referência de variável usando del.
"""

a = b = 5
del a
a

b

a = ['x','y','z']
del a[1]
a

"""# if, else, elif

if, else, elif são usados para ramificação condicional ou tomada de decisão.
"""

x = 1
y = 2

if x > y:
    print("x é maior que y")

elif x < y:
    print("y é maior que x")

else:
    print("São o mesmo número")

"""# except, raise, try

except, raise, try são usados com exceções em Python.

As exceções são basicamente erros que sugerem que algo deu errado durante a execução do nosso programa. IOError, ValueError, ZeroDivisionError, ImportError, NameError, TypeError etc. são alguns exemplos de exceção em Python. blocos try...except são usados para capturar exceções em Python.

Podemos lançar uma exceção explicitamente com a palavra-chave raise. Segue um exemplo:
"""

def reciprocal(num):
    try:
        r = 1/num
    except:
        print('Exception caught')
        return
    return r

print(reciprocal(10))
print(reciprocal(0))

"""# finally

finally é usado com try…except block para fechar recursos ou fluxos de arquivos.

O uso de finally garante que o bloco de código dentro dele seja executado mesmo se houver uma exceção não tratada. Por exemplo:


"""

try:
    Try-block
except exception1:
    Exception1-block
except exception2:
    Exception2-block
else:
    Else-block
finally:
    Finally-block

"""
Aqui, se houver uma exceção no bloco Try, ela será tratada no bloco 
except ou else. Mas não importa em que ordem a execução flua, podemos 
ter certeza de que o bloco Finalmente é executado mesmo se houver um 
erro. Isso é útil na limpeza dos recursos.

"""

"""# for

for é usado para loop. Geralmente usamos for quando sabemos o número de vezes que queremos fazer um loop.

Em Python podemos usá-lo com qualquer tipo de sequência como uma lista ou uma string. Aqui está um exemplo em que for é usado para percorrer uma lista de nomes:
"""

names = ['John','Monica','Steven','Robin']
for i in names:
    print('Hello '+i)

"""# from, import

A palavra-chave import é usada para importar módulos para o projeto atual. from…import é usado para importar atributos ou funções específicas para o namespace atual.
"""

import math # Importa o pacote math para este projeto;

from math import sqrt # Importa apenas a função de raiz quadrada do pacote.

"""# global

global é usado para declarar que uma variável dentro da função é global (fora da função).

Se precisarmos ler o valor de uma variável global, não é necessário defini-la como global. Isso é entendido.

Se precisarmos modificar o valor de uma variável global dentro de uma função, devemos declará-la com global. Caso contrário, uma variável local com esse nome é criada.
"""

globvar = 10

def read1():
    print(globvar)

def write1():
    global globvar
    globvar = 5

def write2():
    globvar = 15

read1()
write1()
read1()
write2()
read1()

"""Aqui, a função read1() está apenas lendo o valor de globvar. Portanto, não precisamos declará-lo como global. Mas a função write1() está modificando o valor, então precisamos declarar a variável como global.

Podemos ver em nossa saída que a modificação ocorreu (10 é alterado para 5). O write2() também tenta modificar este valor. Mas não o declaramos como global.

Assim, é criada uma nova variável local globvar que não é visível fora desta função. Embora modifiquemos essa variável local para 15, a variável global permanece inalterada. Isso é claramente visível em nossa saída.

# in

in é usado para testar se uma sequência (lista, tupla, string etc.) contém um valor. 

Retorna True se o valor estiver presente, senão retorna False. 

Também é usado em for loops.
"""

a = [1, 2, 3, 4, 5]
5 in a
0 in a

for i in 'hello':
    print(i)

"""# is

O is é um operador de igualdade mais forte, ele é usado para dizer se dois objetos são identicos, porém ele é diferente do "==", pois o "==" é usado para dizer se dois objetos são iguais, já o is diz se eles são o mesmo.
"""

[] is [] # False, pois mesmo que ambas as listas estejam vazias elas podem ser modificadas
         # Logo, ocupam diferentes espaços na memória.

() is () # True, pois tuplas são imutáveis

"""# lambda

lambda é usado para criar uma função anônima (função sem nome). 

É uma função inline que não contém uma instrução de retorno. Consiste em uma expressão que é avaliada e retornada.
"""

a = lambda x: x*2
for i in range(1,6):
    print(a(i))

"""# nonlocal

O uso da palavra-chave não local é muito semelhante à palavra-chave global. nonlocal é usado para declarar que uma variável dentro de uma função aninhada (função dentro de uma função) não é local para ela, o que significa que está na função de inclusão externa. 

Se precisarmos modificar o valor de uma variável não local dentro de uma função aninhada, devemos declará-la com não local. Caso contrário, uma variável local com esse nome é criada dentro da função aninhada.
"""

def outer_function():
    a = 5
    def inner_function():
        nonlocal a
        a = 10
        print("Inner function: ",a)
    inner_function()
    print("Outer function: ",a)

outer_function()

"""# pass

pass é uma declaração nula em Python. Nada acontece quando é executado. Ele é usado como um marcador de posição.
"""

def exemplo():
    pass

while True:
    pass

for i in range(0, 1):
    pass

"""# return

É usado dentro de funções para que elas retornem algo.
"""

def func_return():
    a = 10
    return a

def no_return():
    a = 10

print(func_return())
print(no_return())

"""# while

É o segundo tipo de loop do Python, diferente do for, que é usado quando sabemos o número de vezes que queremo realizar uma ação, o while contínua indefinidamente, até que alcance uma condição, ou seja usado o break.
"""

flag = 0
while flag < 10:
    print(f"Counting {flag + 1}...")
    flag += 1

"""# with

with é usado para envolver a execução de um bloco de código dentro de métodos definidos pelo gerenciador de contexto.

O gerenciador de contexto é uma classe que implementa os métodos __enter__ e __exit__. 

O uso da instrução with garante que o método __exit__ seja chamado no final do bloco aninhado. Este conceito é semelhante ao uso do bloco try…finally.
"""

with open('example.txt', 'w') as my_file:
    my_file.write('Hello world!')

"""O with é usado para trabalhar com arquivos no python,
pois ele automaticamente fecha o arquivo."""

"""# yield

yield é usado dentro de uma função como uma instrução return. Mas o rendimento retorna um gerador.

Generator é um iterador que gera um item por vez. Uma grande lista de valores ocupará muita memória. Os geradores são úteis nessa situação, pois geram apenas um valor por vez, em vez de armazenar todos os valores na memória.
"""

def generator():
    for i in range(6):
        yield i*i

g = generator()
for i in g:
    print(i)

"""# Por hoje é isso (づ｡◕‿‿◕｡)づ:"""